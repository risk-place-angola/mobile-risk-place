# Fastlane configuration for MakaNetu (Risk Place Angola)
# This file contains the fastlane.tools configuration

default_platform(:ios)

# ==========================================
# Build Number Management
# ==========================================
# DEV:  1000-9999  (9000 builds)
# PROD: 10000-19999 (10000 builds)
# ==========================================

# Helper to calculate next build number within range
def next_build_number(current_build, range_start, range_end, lane_name)
  if current_build < range_start
    # First build for this lane
    UI.message "üÜï Iniciando #{lane_name} builds em #{range_start}"
    return range_start
  elsif current_build >= range_start && current_build < range_end
    # Increment within range
    next_build = current_build + 1
    remaining = range_end - next_build
    UI.message "üìä #{lane_name} build: #{next_build} (#{remaining} builds restantes na faixa)"
    
    # Warning if approaching limit
    if remaining < 100
      UI.important "‚ö†Ô∏è  ATEN√á√ÉO: Apenas #{remaining} builds restantes para #{lane_name}!"
      UI.important "‚ö†Ô∏è  Considere expandir a faixa de build numbers no Fastfile"
    end
    
    return next_build
  else
    # Reached range limit
    UI.error "üö® LIMITE ALCAN√áADO para #{lane_name}!"
    UI.error "üö® Build atual: #{current_build} >= limite: #{range_end}"
    UI.error "üö® Por favor, expanda as faixas de build numbers no Fastfile"
    raise "Build number limit reached for #{lane_name}. Current: #{current_build}, Limit: #{range_end}"
  end
end

# Get the latest build number from specific range
def get_latest_build_in_range(api_key, app_identifier, range_start, range_end, lane_name)
  begin
    # Get latest build from App Store Connect (all builds)
    latest_build = app_store_build_number(
      api_key: api_key,
      app_identifier: app_identifier,
      live: false
    )
    
    UI.message "üì¶ √öltimo build no App Store Connect: #{latest_build}"
    
    # If latest is within our range, use it
    if latest_build >= range_start && latest_build < range_end
      return latest_build
    end
    
    # If latest is before our range, start at range_start - 1
    # (will be incremented to range_start by next_build_number)
    if latest_build < range_start
      UI.message "‚¨ÖÔ∏è  Build atual (#{latest_build}) est√° antes da faixa #{lane_name}, iniciando em #{range_start - 1}"
      return range_start - 1
    end
    
    # If latest is after our range, we need to scan for the highest in our range
    # For now, start at range_start - 1 (will need manual adjustment if needed)
    UI.important "‚ö†Ô∏è  Build atual (#{latest_build}) est√° fora da faixa #{lane_name} (#{range_start}-#{range_end})"
    UI.important "‚ö†Ô∏è  Iniciando #{lane_name} do come√ßo da faixa: #{range_start}"
    return range_start - 1
    
  rescue => ex
    UI.important "‚ö†Ô∏è  N√£o foi poss√≠vel obter build number: #{ex.message}"
    UI.important "‚ö†Ô∏è  Iniciando #{lane_name} em #{range_start}"
    return range_start - 1
  end
end

# ==========================================
# iOS Platform
# ==========================================
platform :ios do
  before_all do
    setup_ci if ENV['CI']
  end

  # ==========================================
  # LANE: Development Build (TestFlight)
  # ==========================================
  desc "Build and distribute iOS development build to TestFlight"
  lane :dev do
    # Setup API key first to fetch latest build number
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: ENV['APP_STORE_CONNECT_API_KEY_PATH']
    )
    
    # Get latest build number in DEV range (1000-9999)
    UI.message "üîç Buscando √∫ltimo build de DEV (faixa: 1000-9999)..."
    latest_build = get_latest_build_in_range(
      api_key,
      "ao.riskplace.makanetu",
      1000,
      10000,
      "DEV"
    )
    
    # Calculate next build number within DEV range
    dev_build = next_build_number(latest_build, 1000, 10000, "DEV")
    
    # Set build number
    increment_build_number(
      xcodeproj: "ios/Runner.xcodeproj",
      build_number: dev_build
    )

    # Get certificates and provisioning profiles using match
    match(
      type: "appstore",
      readonly: true,
      app_identifier: "ao.riskplace.makanetu",
      git_url: ENV['MATCH_GIT_URL']
    )

    # Build the app
    build_ios_app(
      workspace: "ios/Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates",
      export_options: {
        provisioningProfiles: {
          "ao.riskplace.makanetu" => "match AppStore ao.riskplace.makanetu"
        }
      },
      output_directory: "./build/ios",
      output_name: "makanetu-dev.ipa"
    )

    # Upload to TestFlight with tester groups (api_key already configured above)
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: true,
      notify_external_testers: true,
      groups: ["Nete Testers"],
      changelog: "Development build #{ENV['GITHUB_RUN_NUMBER']} - #{Time.now.strftime('%Y-%m-%d %H:%M')}"
    )
  end

  # ==========================================
  # LANE: Production Release (Build Only - Manual TestFlight Review)
  # ==========================================
  desc "Build production IPA for manual App Store submission (no TestFlight upload)"
  lane :beta do
    # Setup API key first to fetch latest build number
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: ENV['APP_STORE_CONNECT_API_KEY_PATH']
    )
    
    # Get latest build number in PROD range (10000-19999)
    UI.message "üîç Buscando √∫ltimo build de PROD (faixa: 10000-19999)..."
    latest_build = get_latest_build_in_range(
      api_key,
      "ao.riskplace.makanetu",
      10000,
      20000,
      "PROD"
    )
    
    # Calculate next build number within PROD range
    prod_build = next_build_number(latest_build, 10000, 20000, "PROD")
    
    # Set build number
    increment_build_number(
      xcodeproj: "ios/Runner.xcodeproj",
      build_number: prod_build
    )

    # Get certificates and provisioning profiles using match
    match(
      type: "appstore",
      readonly: true,
      app_identifier: "ao.riskplace.makanetu",
      git_url: ENV['MATCH_GIT_URL']
    )

    # Build the app for App Store submission
    build_ios_app(
      workspace: "ios/Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates",
      export_options: {
        provisioningProfiles: {
          "ao.riskplace.makanetu" => "match AppStore ao.riskplace.makanetu"
        }
      },
      output_directory: "./build/ios",
      output_name: "makanetu-prod.ipa"
    )

    # Build complete - IPA ready for manual TestFlight review and App Store submission
    UI.success "‚úÖ Production build completed!"
    UI.success "üì¶ IPA Location: ./build/ios/makanetu-prod.ipa"
    UI.success "üìã Build Number: #{lane_context[SharedValues::BUILD_NUMBER]}"
    UI.message "‚û°Ô∏è  Next steps:"
    UI.message "   1. Download the IPA from CI artifacts"
    UI.message "   2. Upload manually to TestFlight via App Store Connect"
    UI.message "   3. Review and test on TestFlight"
    UI.message "   4. Submit for App Store review when ready"
  end

  # ==========================================
  # LANE: Submit to App Store Review (Manual)
  # ==========================================
  desc "Submit the latest TestFlight build to App Store Review"
  lane :release do
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: ENV['APP_STORE_CONNECT_API_KEY_PATH']
    )
    
    deliver(
      api_key: api_key,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      skip_binary_upload: true,  # Use existing TestFlight build
      skip_metadata: false,
      skip_screenshots: false,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )
  end

  # ==========================================
  # LANE: Setup Certificates (Match)
  # ==========================================
  desc "Setup certificates and provisioning profiles"
  lane :setup_certificates do
    match(
      type: "development",
      app_identifier: "ao.riskplace.makanetu",
      readonly: false
    )

    match(
      type: "appstore",
      app_identifier: "ao.riskplace.makanetu",
      readonly: false
    )
  end
end

# ==========================================
# Android Platform
# ==========================================
platform :android do
  before_all do
    setup_ci if ENV['CI']
  end

  # ==========================================
  # LANE: Development Build (Firebase)
  # ==========================================
  desc "Build and distribute Android development build to Firebase"
  lane :dev do
    # Build the app
    gradle(
      task: "assemble",
      build_type: "Debug",
      project_dir: "android/"
    )

    # Upload to Firebase App Distribution
    firebase_app_distribution(
      app: ENV['FIREBASE_APP_ID_ANDROID'],
      groups: "nete-testers",
      release_notes: "Development build #{ENV['GITHUB_RUN_NUMBER']} - #{Time.now.strftime('%Y-%m-%d %H:%M')}",
      android_artifact_type: "APK",
      android_artifact_path: "build/app/outputs/flutter-apk/app-debug.apk",
      firebase_cli_token: ENV['FIREBASE_CLI_TOKEN']
    )
  end

  # ==========================================
  # LANE: Production Testing (Internal + Open Testing)
  # ==========================================
  desc "Build and upload to Google Play Internal and Open Testing"
  lane :beta do
    # Build the app bundle
    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: "android/"
    )

    # Upload to Internal Testing first (obrigat√≥rio para novos apps)
    upload_to_play_store(
      package_name: "ao.riskplace.makanetu",
      track: "internal",
      aab: "build/app/outputs/bundle/release/app-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "completed",
      rollout: "1.0"
    )

    # Aguardar alguns segundos para processar
    sleep(10)

    # Promover para Open Testing (14 dias obrigat√≥rios)
    upload_to_play_store(
      package_name: "ao.riskplace.makanetu",
      track: "internal",
      track_promote_to: "beta",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_apk: true,
      skip_upload_aab: true,
      release_status: "completed",
      rollout: "1.0"
    )
  end

  # ==========================================
  # LANE: Production Release
  # ==========================================
  desc "Build and submit to Google Play Store"
  lane :release do
    # Build the app bundle
    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: "android/"
    )

    # Upload to Google Play Production
    upload_to_play_store(
      package_name: "ao.riskplace.makanetu",
      track: "production",
      aab: "build/app/outputs/bundle/release/app-release.aab",
      skip_upload_metadata: false,
      skip_upload_images: false,
      skip_upload_screenshots: false,
      release_status: "draft",
      rollout: "0.1"
    )
  end
end
